{"pages":[{"title":"","text":"About me","link":"/about/index.html"}],"posts":[{"title":"Request的封装","text":"在Django的RestFrameWork中，我们常用的是CBV（注意不是不能用FBV，FBV可以通过装饰器的形式去实现），而且CBV继承的不是原生的django的View，而是DRF在Django的view基础上进一步封装的APIView，在这一步进行了Request的重新封装，接下来看一下新的Request都封装了哪些内容。 封装过程整个流程从一个请求进来开始说： 1234from rest_framework.views import APIViewclass AuthView(APIView): pass rest_framework的APIView默认继承Django的View，CBV中找到对应的request的请求方法是利用反射来实现的，原生Django View通过dispatch方法来实现： 12345678910# 原生Django Viewdef dispatch(self, request, *args, **kwargs): # Try to dispatch to the right method; if a method doesn't exist, # defer to the error handler. Also defer to the error handler if the # request method isn't on the approved list. if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed return handler(request, *args, **kwargs) 不过我们知道，我们可以在自己的CBV中重写这个dispatch，借此来实现更多的操作。先调用一下父类（View）的dispatch方法，然后在调用之前和调用之后就可以做一些我们自己的操作了，其实DRF的APIView也是这么干的。 12345678910111213141516171819202122232425262728# DRF的dispatch，drf的dispatch和django的dispatch几乎是一致的，只不过在原来的基础上加了一些钩子，也就是我们所说的在调用父类的操作之前，执行一些其他的方法。这些钩子分别存在于开始，结束以及异常的时候。def dispatch(self, request, *args, **kwargs): self.args = args self.kwargs = kwargs # 1、首先从这里开始，DRF对django的request做了封装。 # 这个request已经发生变化了，是经过drf加工过后的request了。 request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: self.initial(request, *args, **kwargs) # Get the appropriate handler method if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed response = handler(request, *args, **kwargs) except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response 在dispatch这一步骤，request被重新赋值，已经不是原生的request了，而是经过DRF封装之后的Request。调用了初始化的方法，来看一下这个方法具体做了什么： 12345678910111213141516# initialize_requestdef initialize_request(self, request, *args, **kwargs): \"\"\" 返回初始化的request对象，这个对象是drf的Request的对象，相当于在原基础上封装了更多的内容 但是原来的django的request给封装到了返回的对象里，所以说依然可以使用之前的request。 \"\"\" parser_context = self.get_parser_context(request) # _request：原生的request，authenticators获取认证类的对象。 return Request( request, # 这里返回的Request的实例对象，将原生的Django的request封装进去了。 parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) 在初始化的这一步里返回了Request实例化后的对象并复制给request，到此为止，Request被封装完毕，接下来大概粗略的浏览一下我们可以调用这个封装的request的什么属性。 常用属性 _request： 在构造函数中，self._request = request，原生的request被封装进_request中 content_type：返回请求头的类型，默认从self._request.META中去取。 query_params：GET请求的参数，如果我们自己拿的话需要request._request.GET.get，其实这一个步骤相当于DRF帮我去做了。 值得注意的就是request内部还有一个__getattr__方法，这个方法允许我们调用封装的request中没有的属性的时候，会去原生的request中去调用返回。 123456789def __getattr__(self, attr): \"\"\" If an attribute does not exist on this instance, then we also attempt to proxy it to the underlying HttpRequest object. \"\"\" try: return getattr(self._request, attr) except AttributeError: return self.__getattribute__(attr)","link":"/2019/08/02/1.python/article-title/"},{"title":"[GO]1.1-Go基础环境搭建","text":"Go开发环境部署 Golang下载地址：https://golang.org/dl/ 软件的部署与安装 WindowsWindows安装可以参考官方文档，下载对应的windows版本就可以了，然后需要设置环境变量，官方建议直接把go解压到c盘下，如果你是解压到了其他的环境下的话那么需要设置GOROOT的环境变量。 MAC &amp; Linux环境略 IDE编码环境可以使用idea的，也可以使用vscode或者sublime。 main函数只能有一个， 不推荐两句写一行，而且不需要分号，go取巧的地方在于在编译的时候它会给你每一行加一个分号，省的你自己去加这个分号了。 go中强制性的规范，不允许你把花括号单独一行，一定要跟在函数的后面。否者会报错，这相当于强制把代码规范了一下，风格很统一。 假如说有一个变量没有被引用到，那就编译不过去，这样其实是为了减少代码的冗余。也就是说你必须所有的变量都是被引用到的。 强迫你删除没用到的变量。 调试工具：go get github.com/derekparker/delve/cmd/dlv 如果是mac环境的话直接用brew安装就可以了 brew install go-delve/delve/delve 要熟练应用打断点。 go垃圾回收 内存自动回收，再也不需要开发人员管理内存 开发人员专注业务实现，降低了心智负担 只需要new分类内存，不需要释放 后台gc线程自动扫描，当前没有使用的对象会被回收。 天然并发 从语言层面支持并发，非常简单 goroute，轻量级线程，创建成千上万个goroute称为可能 基于CSP（Communicating Sequential Process）模型实现 123func main(){ go fmt.Printlin(\"hello\")} := 自动定义，如果是字符串就是声明字符串，如果是int就是声明int Hello World1234567891011package mainimport \"fmt\"import \"time\"// 入口函数，编译成二进制的时候执行的入口函数就是这个main函数func main() { fmt.Println(\"Hello World\") // 调用Sleep方法进行sleep的操作，5s，在使用前需要引入对应的包 time.Sleep(time.Second*5)} 关于go build当你的目录层级是： 123456.|-- bin|-- pkg`-- src |-- lesson1 |-- helloworld.go 使用go build lesson1就可以进行编译了，go build后面接的是你那个源码package的位置比如lesson1就是你那个包名的地址 当你的目录层级是这样的时候，也就是嵌套的层级的时候 123456789☺ tree -L 5 |-- bin|-- pkg| `-- darwin_amd64`-- src `-- github.com |-- luffy |-- lesson2 `-- identify.go 当采用第二种目录组织方式的时候，就是嵌套层级的情况下应该带上嵌套的层级目录go build github.com/luffy/lesson2，以src为顶级。 go build的产物go build后默认生成的文件的位置为当前路径，不过有的时候我们也想指定生成的位置，这个时候可以通过-o参数来指定，比如 1go build -o bin/hello github.com/luffy/lesson1 其中-o参数放在前面，放在后面我遇到报错了，直接将-o识别为一个package了。 123456☺ go build github.com/luffy/lesson1 -o ./bin/lesson2 master 6804cf1 ✗can't load package: package -o: cannot find package \"-o\" in any of: /usr/local/Cellar/go/1.11.1/libexec/src/-o (from $GOROOT) /Users/lamber/go_workspace/Go_study_notebook/src/-o (from $GOPATH)can't load package: package ./bin/lesson2: cannot find package \"./bin/lesson2\" in: /Users/lamber/go_workspace/Go_study_notebook/bin/lesson2 关于golang的package的最佳实践: package is folder. package name is folder name. package path is folder path. go build是其中一种方式，当然还可以使用go run的方式进行测试，但是go run的方式就要写全了，比如： 1go run src/github.com/luffy/lesson3/test.go 路径精确到文件名。","link":"/2019/11/06/6.go/1.1-Go基础环境搭建/"}],"tags":[{"name":"DRF","slug":"DRF","link":"/tags/DRF/"},{"name":"Go","slug":"Go","link":"/tags/Go/"}],"categories":[{"name":"Django","slug":"Django","link":"/categories/Django/"},{"name":"Go","slug":"Go","link":"/categories/Go/"}]}